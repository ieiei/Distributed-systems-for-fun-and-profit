# 3. 时间和顺序

顺序是什么？顺序为什么这么重要？

你想通过"顺序是什么"来说明什么?

我想说，为什么我们要把顺序放在首位？为什么我们要关系A是不是在B之前发生？为什么我们不关注其他属性，比如“颜色”呢？

好的，抓狂的朋友们，让我们回到分布式系统上来回答这些问题吧。

你们可能记得，我之前说到分布式编程是一门用多台机器来解决同样你可以在一台机器解决的问题的艺术。

事实上，痴迷于顺序的核心是，任何一个系统在一个时间只能做一件事情，因此对于一些操作来说必然会有一套完整的顺序。就像人们穿过一个单通道的门一样，每个穿过者都会有前任和继任。这就是我们努力保护的基本编程模型。

传统的模型是一个单通道程序，一个进程，一个内存空间运行在一个CPU上。操作系统将这个事实抽象成看上去有多个CPU运行者多个程序一样，内存也在多个进程之间共享者。我没说到多线程编程和事件驱动编程；这也是在“一/一/一（指上面一个进程，一个内存，一个CPU）模型上的一个特殊抽象。程序被写出来是在一定的顺序方式下执行：你从头开始执行，然后逐渐执行到底部。

顺序作为一种属性获取了如此多的关注



## 全局排序和局部排序

一个分布式系统处在自然状态是一个[局部顺序](http://en.wikipedia.org/wiki/Partially_ordered_set)。不仅是网络还有系统上所有的独立节点都是通过相对顺序来做保证的；但是对于每一个节点本身来说，你看到的是一个本地的顺序。

一个[全局排序](http://en.wikipedia.org/wiki/Total_order)是一个用一些集合来定义每一个元素的顺序的二进制联系。

两个不同的元素之间存在着其中一个比另外一个大的这种比较关系。在一个局部排序集合中，一些元素对之间没有相互比较导致这个局部排序不能准确描述每一项的顺序。

不论全局排序还是局部排序都是可传递的以及对称的。下面描述a，b，c关系的语句对于全局排序和局部排序都适用：

```
If a ≤ b and b ≤ a then a = b（对称性）;
If a ≤ b and b ≤ c then a ≤ c（传递性）;
```

但是，一个全局排序是[全局性](http://en.wikipedia.org/wiki/Total_relation)：

```
a ≤ b or b ≤ a (全局性) for all a, b in X 
```

而一个局部排序只有[自反性](http://en.wikipedia.org/wiki/Reflexive_relation):

```
a ≤ a (自反性) for all a in X
```

注意有全局性同样也意味着有自反性；所以一个局部排序是一个全局排序的弱变体。对于在一个局部排序体系里的所有元素来说，是不包含全局性的 - 换句话说就是有些元素没法进行比较。

Git的分支就是一个局部排序的例子。正如你可能知道，git版本控制系统允许你从一个基础分支（比如master分支）拉出很多新分支。每个分支都能看到从同一个祖先继承下来的所有代码变更的历史记录。

```
[ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]
[ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]
                  \  [ master (1,0,0) ]  /
```

A分支和B分支都起源了同一个祖先，但是



## 什么是时间？

时间是顺序的源 - 时间允许我们来定义操作的顺序 - 巧合的是时间还是人们都可以理解的表达方式（一秒，一分，一天等等）。

在一些场景中，时间仅仅跟其他整型计数器一样。

- 顺序
- 间隔
- 描述

*顺序*，我之前说到时间是顺序的源，这个意思是：

- 我们可以将无序的事件绑上时间戳来对它们排序